# Creating a special Bluetooth keyboard with Adafruit

Bluetooth LE is a delightful protocol that lets you build smart devices (we will make a smart keyboard in this article) and control it. However, actually using the Adafruit Bluetooth LE libraries is a little painful. It's not always obvious how the library works, or what you need to provide in order add your own services and characteristics.

In this series, I'll be modernizing a vintage Atari CX85 so that it supports Bluetooth. I'll also use this as an opportunity to make the keyboard much smarter than a standard keyboard, which in turn also means creating a small Windows app to listen for this specialized keyboard and translate its key presses.

## IP: a little bit about BT services and characteristics

## IP: a little bit about BT keyboards

## IP: setting the time!

Is there a bluetooth time beacon?
[Current Time Service](https://www.bluetooth.com/specifications/specs/current-time-service-1-1/)

Current Time Service is 0x1805
Characteristics:
Current Time Characteristic is 0x2A2B
Local Time Characteristic 0x2A0F
Reference Time Information Characteristic 

Contents are descibed in [Nordic](https://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk5.v12.2.0%2Fstructexact__time__256__t.html)
u16_year, u8_month, u8_day, u8_hours, u8_minutes, u8_seconds, 


There's a weird heirarchy of times for no good reason:



|BLE Type|BLE Name|Parent Field Type|.. Name|GParent Field Type|..Name|GGParent Field Type|
|----|----|----|----|----|----|----|
|u16|year|ble_date_time_t|date_time|day_date_time_t|day_date_time|exact_time_256_t
|u8|month|ble_date_time_t|date_time | | | 
|u8|day|ble_date_time_t|date_time | | | |
|u8|hours|ble_date_time_t|date_time
|u8|minutes|ble_date_time_t|date_time
|u8|seconds|ble_date_time_t|date_time
|u8|day_of_week| ||day_date_time_t|day_date_time|
|u8|fractions256|||||exact_time_256_t|

Except there is a reason: this is what's in the Bluetooth Sig guides. Take a look at the SIG [CurrentTimeService_CTS_SPEC_V1.1.0.pdf](https://www.bluetooth.com/specifications/specs/current-time-service-1-1/) file. It says that the Current Time is defined by the "Exact Time 256". This is defined in [GATT_Specification_Suppliment_v8.pdf](https://www.bluetooth.com/specifications/specs/) (you need to scroll *way* down to get to it). That spec lists all of these data types. You can find Exact Time 256 there as a Day Date Time plus a Fransion256. Just keep pawing through at you'll find it all.

## Measuring the battery power

Link: [https://learn.adafruit.com/introducing-the-adafruit-nrf52840-feather/power-management-2](https://learn.adafruit.com/introducing-the-adafruit-nrf52840-feather/power-management-2)

There's a 1/2 of battery voltage available on analog A6. That pin is not exposed on the breakout (it just goes A0 to A5), so that value is available for use. They call it A6, but you have to refer to it as ```board.VOLTAGE_MONITOR``` (for CircuitPython). Arduino people can call it A6 but it's commonly converted to ```#define VBATPIN A6```.

The voltage is measure with this function:
```
    #
    # Power and battery section
    #
    batteryPin = AnalogIn(board.VOLTAGE_MONITOR)

    def get_battery_voltage(self):
        return 2.0 * (self.batteryPin.value * 3.3) / 65536.0    
```

The code is eventually called from the main pin-reading loop and logs the battery voltage about every 60 seconds. Note that logging data doesn't turn on the display. The values I see start out at about 4.2 volts and slowly decrease to 3.something.

## Picking GUIDs for Bluetooth

Bluetooth services and characteristics are all specified by GUID. Many devices -- even from well-known companies -- have a habbit of using impropertly-created GUIDs. This is wrong; a proper GUID can only be generated by a "real" GUID program. You should never just type in random letters and numbers to create one, you should never reuse one, and you should never make one by incrementing an existing GUID.

GUIDs (also known as UUID) are carefully designed (see [RFC 4122](https://www.rfc-editor.org/rfc/rfc4122)) so that any number of people can each make GUIDs without having them overlap. If you create a GUID by hand (by just typing in hex letters and numbers), you run the risk of re-using a GUID. This is not good.

People create their GUID by hand because they like to have a "set" of GUIDs so that all of their services and characteristics all match in some way. Among other things, it makes debugging your devices a little easier. Luckily, although we can't make just any old GUID, we **can** generate as many GUIDs as we like and filter out the ones we want to keep.

For this project, I decided that every GUID would start with "b7b0a" -- so it looks a little bit like "BT Board" as in BT Keyboard. Using a 7 for the 'T' is normal "leetspeak".

Because I use Windows, I generate the GUIDs with PowerShell. I'm not in any way a PowerShell expert. 

The simplest way to make a GUID in PowerShell is the **new-guid** command. I created a tiny little script to make Guids in a loop and only print the ones that match my "lookfor" value.

```powershell
$lookfor = "b7b0a"
while ($true) {
    $guid = new-guid
    if ($guid.ToString().StartsWith($lookfor)) {
        Write-Output $guid
    }
}
```

I've found that on a modern low-end laptop that I can generate about 2 GUIDs that match 5 letters per minute. I just left the script running during lunch to generate a long list, and those are the GUIDs used in my project.


# Writer's Notes

*Delete all these*

